----------------- Configuración inicial -------------------------

1. Crear aplicación en meteor en consola

  -> meteor create microscope //microscope es el nombre de la app

2. Añadir twt bootstrap

  -> meteor add twbs:bootstrap

3. Añadir underscore

  Underscore es una librería para manipular estructuras de datos Javascript

  -> meteor add underscore

4. borrar archivos por defecto y establecer un scaffold amigable

  -> client

  -> server

  -> public

  -> lib

5. crear main.html y main.js la carpeta destinada para el cliente. También el css
  con el estilo correspondiente. ( :

*****************************************************************
Se utiliza camelCase sobre underscore por cuestiones de costumbre
*****************************************************************

-------- Creando las vistas del lado del cliente --------------

1. la etiqueta {{> postList }} (se les denomina, inclusiones) nos indica que un valor será
  desplegado, debe asignarse en el lugar correcto.

2. Creamos una carpeta específica para los templates (partials/components) del elemento
  "posts", llamaremos a la primer carpeta "templates" donde estarán todos los templates
  necesarios y dentro de ella colocaremos la carpeta "posts", en la cual estará el html
  correspondiente a los template.

3. En la carpeta posts, crearemos el archivo post_list, donde estará el template para
  mostrar todos los posts.. ( :

  Aquí con un {{#each post}} iteramos entre los valores del objeto postItem, y en el cual
  mostramos el resultado en el valor {{> postItem}}.

4. Creamos el archivo post_item, donde estará el template de cada item de los post, el cual
  contendrá una etiqueta {{url}} con su dirección, {{title}} con su título y {{domain}} con el
  valor de dominio.

  el atributo name="postsList" en el template, es el que usa meteor para saber que
  template debe renderizar en la sección donde es llamado.


---------------------------------------------------------- > Tratando sobre helpers

En palabras cortas, ayudarán a mejorar la forma en que la data puede verse en el documento final.

crearemos nuestro primer helper con la ayuda de posts_list.js

Podemos ver a nuestro helper creado "post", para utilizar el contenido de la variable "postData"
en cualquiera de nuestros templates.

---------------------------------------------------------- > Tratando sobre helpers

OBSERVACIONES:

  - Al tener una carpeta denominada "cliente" meteor asume que esta es la carpeta raiz
  - Al tener denominado un archivo "main.html" hará de cuenta que es el index de la carpeta
  - A la hora de incluir un template, no importa en que carpeta este se encuentre
  _______________________________________________________________________________________

  5. Creamos el helper para la url del post.. Nos devolverá unicamente el dominio, creando una
    etiqueta a en memoria, asignándole como url la url del post en el template, y devolviéndonos
    el hostname de la etiqueta a.



==========================================================================================
================================== COLECCIONES ===========================================
==========================================================================================

Una colección es una base de datos en meteor.. Maneja mongo db, gestor de base de datos en
javascript.

1. Crearemos una colección llamada Posts, en el archivo posts.js en la carpeta collections
  dentro de la carpeta lib.. Con "Posts = new Mongo.Collection('posts');"

  //No se utiliza var, dado qué, eso lo limita al documento, mientras que una variable
  //global, permite la ejecución en todo el servidor

2. se insertará un post de prueba, para familiarizarse con los métodos: db.posts.insert({title: "A new post"});

3. Podemos ver el contenido de la tabla posts con: db.posts.find();

4. Desde la consola del navegador creamos un post nuevo con: Posts.insert({title: "A second post"});
  Y podemos ver que este elemento no solo se crea en la base de datos en caché, sino que crea el registro
  en la base de datos en el servidor.

5. limpiaremos la base de datos para no tener registros por ahora con "meteor reset" en consola.

6. añadiremos en la base de datos los post que usábamos de ejemplo en un archivo por aparte, del lado del
  servidor llamado fixtures.js (server/fixtures.js)

7. Por último, añadiremos en el helper la función necesaria para que nos devuelva los elementos de la
  colección. (client/templates/posts/post_list.js)

  ==========================================================================================
  ================================== AUTOPUBLISH ===========================================
  ==========================================================================================

Autopublish es un paquete que permite que el cliente pueda acceder a toda la base de datos, en
desarrollo puede ayudarnos a formar toda la interacción, pero, en producción podría permitir que
cualquier usuario pudiera obtener la data que quisiera..

Lo retiraremos.. (Consola: meteor remove autopublish)

Ahora el cliente deberea suscribirse para poder acceder a los datos de la base de esta manera.

1. En la carpeta server, crearemos un archivo llamado "publications.js" en el cual enviaremos
  la base de datos a publicarse.

2. En la carpeta client, en main.js haremos que el cliente se suscriba a esa base de
  datos (Meteor.subscribe('posts');)

Meteor trabaja fundamentalmente con los datos en metodología DDP (Distributed Data Protocol) por
  lo cual, podemos regular la data enviada al cliente, y que este puede recibir para hacer la
  interacción entre él y el servidor.

  ==========================================================================================
  ================================= /AUTOPUBLISH ===========================================
  ==========================================================================================

  ==========================================================================================
  ================================== IRON ROUTER ===========================================
  ==========================================================================================

En la mayoría de apps, necesitaremos url's individuales para cada post, de esta manera podremos
acceder a ellos sin tener en cuenta los demás datos, y para el routing, necesitamos un router,
utilizaremos iron router, y utilizaremos de identificador de la url el id.

1. Instalar iron router (meteor add iron:router)

La idea de utilizar rutas, también nos permite especificar templates que siempre tienen un patrón
y actualizar únicamente el contenido en su interior, para esto se utilizaría una sección para las
casillas ({{> yield}}), se utiliza un helper para ello.

2. Creamos la carpeta application, y en su interior el layout (layout.html) el cual se repetirá,
  mientras que en main.html, sólo dejaremos el head de nuestro website. cambiaremos también "postList"
  por "yield".

3. también cambiaremos las etiquetas "body" por "template", y al template le asignaremos un
nombre (name="layout"), así se identificará meteor de que llamamos a ese layout.

4. Crearemos un archivo dentro de la carpeta lib llamado router.js, el cual se encargará de
  especificar las rutas para que la app funcione cómo esperamos.

5. En la configuración del Router, crearemos la suscripción de los post. (waitOn: function() {return Meteor.subscribe('posts');})

6. Asignaremos también un template loading, que estará visible mientras los posts estén cargando.

7. agregaremos un paquete de spinners para el template de carga.. (meteor add sacha:spin ) y lo usaremos
  en el template de loading.

8. Crearemos la ruta para el template de cada post individual y el template en si..

  8.1 archivo en: "./client/posts/post_page.html"

  8.2 en el router (Router.route('/posts/:_id', { name: 'postPage' });)

  8.3 En el router se envía la data a visualizarse:

    (data: function() { return Posts.findOne(this.params._id); })

-------------------------->

  Si hiciéramos una ruta por cada post, tendríamos que crear muchas y actualizarlas al día, por
  lo cual creamos una ruta dinámica, donde toma el id para crear la ruta para cada post.

-------------------------->

  8.4 Crear un botón que hace referencia a la discusión en el foro, para que otras personas opinen
    acerca de el, para esto usaremos la ruta, crearemos un botón en el template del item.

    (<a href="{{pathFor 'postPage'}}" class="discuss btn btn-default">Discuss</a>)

9. Estableceremos también una ruta para el notfound, en el router le asignaremos el template.

10. Crearemos también el archivo not_found.html en el directorio application, y ahí, crearemos
  el template para el not found..

11. Ajustaremos el Router para que también retorne el error 404 cuando la ruta postpages nos
  devuelva un objeto en blanco, o vacio, al igual que un false o undefined.

  (Router.onBeforeAction('dataNotFound', {only: 'postPage'});) //al final del router

  ==========================================================================================
  ==================================== SESIONES ============================================
  ==========================================================================================

Las sesiones nos permiten llevar un control del funcionamiento de la aplicación de acuerdo
al tipo de sesión que lleva, esto nos permite ejecutar o no procesos, mostrar u ocultar elementos
en el cliente, acceder a secciones de la base de datos distintas y demás..

==========================================================================================
=================================== /SESIONES ============================================
==========================================================================================


==========================================================================================
==================================== USUARIOS ============================================
==========================================================================================

Una aplicación por lo general necesitará usuarios para el acceso a distintas secciones, para
que pueda publicar, comentar y demás y la vez, manejar data personal, integraremos dos
paquetes de meteor ya hechos para ayudarnos con la autentificación..

1. instalar ian:accounts (meteor add ian:accounts-ui-bootstrap-3)

2. instalar account password (meteor add accounts-password)

3. Crearemos un template propio para el header y lo retiraremos del layout principal.

4. En el template del header, colocaremos los login buttons necesarios. ( {{> loginButtons}} )

5. Por último, le diremos a la app que utilice el username para iniciar las sesiones a través
  del archivo en "client/helpers/config.js" (ver su contenido).

----------------->
  al añadir el paquete "accounts" meteor creó una especial nueva colección"
      para poder acceder a Meteor.users, la cual contiene los datos de los usuarios
          para su interacción con ellos.
              (se puede comprobar en browser console: Meteor.users.findOne();)
                ------------------------------->



==========================================================================================
=================================== /USUARIOS ============================================
==========================================================================================

==========================================================================================
===================================== POST'S =============================================
==========================================================================================

    CREACIÓN DE POSTS
      1. Se creará una ruta para el formulario del envío de data (submit form)
          (Router.route('/submit', {name: 'postSubmit'});) en router.js

      2. Se creará un link para enviar el contenido de la página en el header.
          (<li><a href="{{pathFor 'postSubmit'}}">Submit Post</a></li>)

      3. Por último, crearemos el evento para que envíe la data del formulario.
        Los detalles estarán en el archivo post_submit.js

==========================================================================================
==================================== /POST'S =============================================
==========================================================================================

(((((((((((((((((((((((((((((((((((((((((INSECURE)))))))))))))))))))))))))))))))))))))))))

Insecure nos permite la interacción desde el cliente/servidor, para que, el cliente pueda
crear, editar, o eliminar contenido de ella sin necesariamente tener accesos, ya que
insecure le permite tener todas las acciones necesarias para ello.

Podemos crear toda la app con ella, y después sólo encargarnos de limitarla, o podemos
quitar el paquete desde el inicio y hacer la interacción segura desde el desarrollo.

en este caso, la quitaremos desde ahora: (meteor remove insecure)

(((((((((((((((((((((((((((((((((((((((((/INSECURE)))))))))))))))))))))))))))))))))))))))))

==========================================================================================
===================================== POST'S =============================================
==========================================================================================

    CREACIÓN DE POSTS
      4. Y sin insecure, tendremos que especificar en nuestra app que sólo podrán haber
        posts si hay un usuario loggeado en la app, de lo contrario nuestra app no lo
        permitirá. (checar lib/collections/posts.js)

      5. Necesitaremos crear también un template para el acceso denegado, que es lo que aparecerá
        si en algún momento alguien sin la sesión abierta, quisiera crear
        un nuevo post. (checar router.js)

      6. Crearemos también una vista que será visible mientras el cliente verifica con el
        servidor que haya un usuario loggeado a la app, re checar router.

      7. Por último, ocultaremos el botón para crear un nuevo post si el usuario no está
        loggeado..

      8. Crearemos un método para subir el post, el cual tendrá una condicional para verificar
        que no hayan errores en el post. (ver post_submit.js)

      9. instalar check para la verificación de equivalencia de tipo de datos (meteor add check)

      10. validaremos en el archivo de la colección que los datos se ingresen correctamente,
        insertaremos en el objeto el usuario creador, al igual que la fecha en que fue creado.
        Al igual que insertaremos el post y devolveremos el id del post en la función para
        que pueda ser visto por nosotros a la hora de ser creado. (check lib/collections/posts.js)

      11. Verificaremos que un post antiguo no tenga la misma url para que no hayan datos
        duplicados. (check lib/collections/posts.js) Y retornaremos un objeto de ser así.

      12. Crearemos una función que nos dirá que el post ya existe de ser así. (post_submit.js)

==========================================================================================
==================================== /POST'S =============================================
==========================================================================================

(((((((((((((((((((((((((((((((((((LATENCY COMPENSATION)))))))))))))))))))))))))))))))))))

----> Checar Branch Latency

  La manera en que meteor trabaja para los cambios en tiempo real es simulándolos a través
  de la base de datos local, en el cual, muestra esos datos y ya colocados en la base de datos
  real, ya muestra la data de esta, lo comprobamos poniendo una condicional en el lado de las
  colecciones, para que nos mostrara la data del cliente mientras el servidor dormía un poco
  para observar esa integración.

(((((((((((((((((((((((((((((((((((/LATENCY COMPENSATION)))))))))))))))))))))))))))))))))))

==========================================================================================
===================================== POST'S =============================================
==========================================================================================

  Al crear la colección "Post", traemos con ella métodos para eliminar y editar posts.

    EDICIÓN DE POSTS

      1. Creamos la ruta para la edición de posts en el router.

      2. Creamos el template para editar el post que se verá en la ruta creada. (post_edit.html)

      3. Crearemos en el template un botón para acceder a la ruta para editar.

      4. Usaremos un helper para decirle al edit post quien es el dueño del post {{ownPost}}
        y que solo este pueda editarlo.

      5. creamos un archivo de permisos para establecer que el usuario puede editar el post
        para editar la base de datos y acceder a ella.

      6. En el archivo de la coleción, permitimos (allow()) que el usuario activo, de ser el creador
        pueda editar el post.

      7. En el mismo archivo, especificaremos que sólo pueden editar las opciones especificadas.

      //extra bonus

      8. Creamos un método al cual llamamos desde el template, el método comprobará que no haya
        ya un post con la url de estar siendo editado, y de ser así nos retornará una alerta.

==========================================================================================
==================================== /POST'S =============================================
==========================================================================================

==========================================================================================
==================================== ERRORES =============================================
==========================================================================================

  1. Creamos una base de datos local del lado del cliente. (client/helpers/errors.js)

  2. Creamos un template para mostrar los errores (te,[;ates/includes/errors.html])

  3. Colocamos la llamada al template de los errores desde el layout para mostrar los errores
    en cualquier vista. (templates/application/layout.html)

  4. Reemplazaremos nuestra alerta por nuestro template con mensajes de error.

  5. Por último, para permitir múltiples mensajes de error, creamos una función para eliminar
    el error de la base de datos del cliente, para poder mostrár las demás tras los 3 segundos.


  //En creación del post

    1. Establecemos en post_submit.js un objeto que se creará cuando se intente crear un post

    2. establecemos dos helper que mostrarán el contenido del objeto de tener algo en él (error)

    3. Colocaremos esos helper en el template para mostrarlos cuando haya un error.

    4. En el archivo posts crearemos un método para validar el post y de no ser correcto,
      desplegará los errores. (lib/collections/posts.js)

    5. También crearemos una validación del lado del servidor en la colección (lib/collections/posts.js)
      donde crearemos un error al haber inconvenientes en la creación del post.

    los mismos procedimientos con edit ( :

==========================================================================================
==================================== /ERRORES ============================================
==========================================================================================

==========================================================================================
===================================== PACKAGES ===========================================
==========================================================================================

  Un paquete se suele crear para compartir código con la comunidad, de manera que pueda ser
  usado en cualquier ocasión por quien lo necesite, haciendo de esta mayor cada vez. Se
  creará uno para mostrar los errores en nuestra app, y en quien quiera usarla.

  1. Crear el paquete en consola meteor create --package aleejandroreyna:errors (username:packageName)

  2. Ajustar el archivo del package (packages/errors/package.js) donde especificamos el summary
    que dependencias tendrá la api ( api.use(['dependencies'], 'side'); )

  3. Adjuntaremos los archivos que la compondrán:
    (  api.addFiles(['file_01', 'file_02'], 'side');  )

  4. exportaremos la api para que pueda utilizarle *esencial?*.. (if(api.export) {content});
==========================================================================================
==================================== /PACKAGES ===========================================
==========================================================================================
